// twitter.js

// IMPORTS
var cheerio = require("cheerio")
var request = require("tinyreq")

// GLOBALS
var BOT = null
var LOGGING_STRING = "twitter.js || "
var DEFAULT_TRANSMIT_DELAY = 800
var DEFAULT_EXTENDED_TRANSMIT_DELAY = 1000


// ---- TWITTER CSS SELECTORS ----------------------------------------------------------------------- //
var TWEET_CONTAINER_CLASS   = ".tweet.permalink-tweet "
var TWEET_AUTHOR_CLASS      = ".fullname "
var TWEET_HANDLE_CLASS      = ".username "
var TWEET_AVATAR_CLASS      = ".permalink-header .avatar "
var VERIFIED_ACCOUNT_CLASS  = "span.Icon--verified "
var TWEET_CONTENT_CLASS     = ".js-tweet-text-container .tweet-text "
var TWEET_IMAGE_CLASS       = ".AdaptiveMedia .js-adaptive-photo img "
var TWEET_VIDEO_CLASS       = ".AdaptiveMedia.is-generic-video "
var TWEET_QUOTE_CLASS       = ".QuoteTweet "
var QUOTE_CONTAINER_CLASS   = ".QuoteTweet-container "
var QUOTE_AUTHOR_CLASS      = ".QuoteTweet-fullname "
var QUOTE_HANDLE_CLASS      = ".QuoteTweet-screenname "
var QUOTE_CONTENT_CLASS     = ".QuoteTweet-text "
// -------------------------------------------------------------------------------------------------- //


// 1.) ---- PUBLIC FUNCTIONS ------------------------------------------------------------------------ //


module.exports = {
    
    // Sets the global bot variable
    //
    // @param BOT The bot being used.
    //
    init_module: function(bot){ 
        log_event("Initizaling Twitter Module...")
        BOT = bot 
    },
    
    // Returns true if the string provided contains a twitter permalink
    //
    // @param MESSAGE A string containing the message
    // @return true if the string provided contains a twitter permalink, false otherwise
    //
    has_tweet: function(message){
        tweets = message.match(/https:\/\/(?:www.){0,1}twitter.com\/\w+\/status\/\d+/g);
        if(tweets != null) return true
        return false;
    },
    
    // Takes in a message containing a tweet URL, reformats the content, and sends it to the channel.
    //
    // @param CHANNELID The channelID the message came from.
    // @param USERID The userID of the sender.
    // @param ORIGINAL_MESSAGE The message sent.
    //
    reformat_tweet: function(channelID, userID, original_message) {
        no_url_message = original_message.replace(/https:\/\/(?:www.){0,1}twitter.com\/\w+\/status\/\d+/g, "[←TWEET→]")
        message_chunks = ['**<@' + userID + '> sent:**\n'].concat(no_url_message.split(/(\[←TWEET→\])/))
        tweets = original_message.match(/https:\/\/(?:www.){0,1}twitter.com\/\w+\/status\/\d+/g);
        transmit_delay = 0
        if(tweets.length > 1) transmit_delay = DEFAULT_EXTENDED_TRANSMIT_DELAY
        process_msg_chunks(channelID, message_chunks, tweets, transmit_delay)
    }

}


// 2.) ---- MESSAGE PROCESSING PIPELINE ------------------------------------------------------------- //


// Processes the chunks broken up by reformat_tweet() and sends the chunks in sequential order
//
// @param CHANNELID The channelID the message came from.
// @param MSG_CHUNKS An array containing the the original message broken into chunks, delineated by tweet URLS.
// @param TWEET_URLS An array of tweet permalinks referenced in MSG_CHUNKS.
// @param DELAY The time to wait inbetween sending messages.
// @param INDEX The current index of MSG_CHUNKS.
// @param TWEET_INDEX The current index of TWEET_URLS.
// @param EXT_LINKS An array containing Discord Embed Objects.
//
// Note: EXT_LINKS contains addtional Discord Embed Objects, generated by format_tweet(), 
//       which are used to display additional tweet information that couldn't be included in 
//       the main tweet Embed Object. Currently, this includes additional images and links.
//
function process_msg_chunks(channelID, msg_chunks, tweet_urls, delay = 0, index = 0, tweet_index = 0, ext_links = []){
    if(index >= msg_chunks.length) return;
    setTimeout(function(){
        // If there are Embed Objects in EXT_LINKS when passed in, send the first Embed Object, remove the object from
        // EXT_LINKS and then recursively call process_msg_chunks() (now with one less Embed Object in ext_links)
        if(ext_links.length > 0){
            console.log("Transmitting Message Chunk: ")
            console.log(ext_links[0])
            BOT.sendMessage({ to: channelID, embed: ext_links.shift() }, function(error, response){
                parse_transmit_error(error)
                process_msg_chunks(channelID, msg_chunks, tweet_urls, delay, index, tweet_index, ext_links)
            })
        // If current message chunk is flagged as a tweet, pull the URL from TWEET_URLS and 
        // send the formatted version of the tweet.
        } else if(msg_chunks[index] === "[←TWEET→]"){
            console.log("Transmitting Message Chunk: [←TWEET→]")
            fetch_tweet_content(tweet_urls[tweet_index], function(embed_object, ext_links, video_link){
                if(video_link != null) message_chunks.splice(index+1, 0, video_link) 
                BOT.sendMessage({ to: channelID, embed: embed_object }, function(error, response){
                    parse_transmit_error(error)
                    if(delay != DEFAULT_EXTENDED_TRANSMIT_DELAY && ext_links.length > 1) delay = DEFAULT_TRANSMIT_DELAY;
                    process_msg_chunks(channelID, msg_chunks, tweet_urls, delay, index+1, tweet_index+1, ext_links)
                });
            });
        // Otherwise, the message chunk is a string, send it as a plain message.
        } else {
            if(msg_chunks[index].match(/[\S]/g) != null){
                console.log("Transmitting Message Chunk: " + msg_chunks[index].replace(/(?:\r\n|\r|\n)/g, '\\n'))
                BOT.sendMessage({ to: channelID, message: msg_chunks[index] }, function(error, response){
                    parse_transmit_error(error)
                    process_msg_chunks(channelID, msg_chunks, tweet_urls, delay, index+1, tweet_index, [])
                })
            } else process_msg_chunks(channelID, msg_chunks, tweet_urls, delay, index+1, tweet_index, [])
        }
    }, delay);
}


// Compiles a JSON Object containing information about a tweet.
//
// @param URL The URL of the tweet.
// @param CALLBACK() The function to call once the tweet has been compiled and formatted.
//        CALLBACK FUNCTION PARAMETERS:
//          - FORMATTED_TWEET  : A Discord Embed Object Containing the formatted Tweet Data
//          - FORMATTED_BLOCKS : An array of Discord Embed Objects used to present additional 
//                               tweet data that could not be included in the FORMATTED_TWEET
//                               Embed Object. (Additional Pictures, Website Links, etc.)
//          - VIDEO_LINK       : The URL of an embedded Twitter video (if one was present in the tweet)
//
function fetch_tweet_content(URL, callback) {
    console.log("Collecting Tweet Data...")
    request(URL, function(err, body){
        if (err){ console.log("Could not resolve URL"); return null; }
        let $ = cheerio.load(body);
        // Get Linked Content
        var linked_content = $(TWEET_CONTAINER_CLASS + TWEET_CONTENT_CLASS + ' .twitter-timeline-link.u-hidden').remove()[0], has_external_link = false
        if(linked_content){
            if(linked_content.attribs['data-expanded-url']){
                linked_content = linked_content.attribs['data-expanded-url']
                has_external_link = true
            } else linked_content = linked_content.attribs.href
        } else linked_content = null
        // Check Account Verification
        var verfied = $(TWEET_CONTAINER_CLASS + TWEET_AUTHOR_CLASS + VERIFIED_ACCOUNT_CLASS).remove().length > 0
        // Compile Tweet Data
        tweet = {
            author: $(TWEET_CONTAINER_CLASS + TWEET_AUTHOR_CLASS).text(),
            handle: $(TWEET_CONTAINER_CLASS + TWEET_HANDLE_CLASS).text(),
            avatar: $(TWEET_CONTAINER_CLASS + TWEET_AVATAR_CLASS)[0].attribs.src,
            verfied: verfied,
            tweet_content: $(TWEET_CONTAINER_CLASS + TWEET_CONTENT_CLASS).text(),
            linked_content: linked_content,
            has_external_link: has_external_link,
            has_video: $(TWEET_CONTAINER_CLASS + TWEET_VIDEO_CLASS).length > 0,
            has_quote: $(TWEET_CONTAINER_CLASS + TWEET_QUOTE_CLASS).length > 0,
            images: parse_images($(TWEET_CONTAINER_CLASS + TWEET_IMAGE_CLASS)),
            quote_author: $(TWEET_CONTAINER_CLASS + QUOTE_CONTAINER_CLASS + QUOTE_AUTHOR_CLASS).text(),
            quote_handle: parse_twitter_handle($(TWEET_CONTAINER_CLASS + QUOTE_CONTAINER_CLASS + QUOTE_HANDLE_CLASS).text()),
            quote_content: $(TWEET_CONTAINER_CLASS + QUOTE_CONTAINER_CLASS + QUOTE_CONTENT_CLASS).text(),             
            tweet_url: URL,
            tweet_type: null
        }
        // Determine Tweet Type
        tweet['tweet_type'] = get_tweet_type(tweet)
        console.log(tweet)
        console.log("Complete.")
        format_tweet(tweet, callback);
    });
}


// Processes a Tweet Object into a series of Discord Embed Objects.
//
// @param TWEET A JSON object containing the Tweet's data.
// @param CALLBACK() The function to call once the tweet has been formatted.
//        CALLBACK FUNCTION PARAMETERS:
//          - FORMATTED_TWEET  : A Discord Embed Object Containing the formatted Tweet Data
//          - FORMATTED_BLOCKS : An array of Discord Embed Objects used to present additional 
//                               tweet data that could not be included in the FORMATTED_TWEET
//                               Embed Object. (Additional Pictures, Website Links, etc.)
//          - VIDEO_LINK       : The URL of an embedded Twitter video (if one was present in the tweet)
//
function format_tweet(tweet, callback){
    formatted_tweet = null, formatted_blocks = [], video_link = null; verified_string = ""
    // Format Verified Account String
    if(tweet['verfied']) verified_string = " | ✓ Verified"
    // Format Tweet Header
    formatted_tweet = {
        color: 44269,
        author: { name: tweet['author'] + " | " + tweet['handle'] + verified_string, icon_url: tweet['avatar'], url: tweet['tweet_url']}
    }
    // Format Tweet Text Content
    if(tweet['tweet_content'] !== '') formatted_tweet['description'] = " ```" + tweet['tweet_content'] + "```\n"
    // If Tweet Contains one or more Images -> Append the first image to formatted_tweet.
    if(tweet['images'].length >= 1) formatted_tweet['image'] = { url: tweet['images'].shift() } 
    // If Tweet Contains Multiple Images -> Format each Image as it's own Embedded Structure
    if(tweet['images'].length > 0) {
        for(var i=0; i < tweet['images'].length; i++) 
            formatted_blocks.push({ color: 44269, image: {url: tweet['images'][i]} })
    }
    // If Tweet is a text_quote -> Set Quoted Tweet as Embedded Field Structure
    if(tweet['tweet_type'] === "text_quote"){
        formatted_tweet['fields'] = [{
            name: ":arrow_lower_right: " + tweet['quote_author'] + " | " + tweet['quote_handle'],
            value: "```" + tweet['quote_content'] + "```",
            inline: false          
        }]
    }
    // If Tweet Contains a Video -> Post the URL directly as plain text.
    if(tweet['has_video']) video_link = ":movie_camera: " + tweet['linked_content']
    // If Tweet is an only_link or text_link -> Format the Link as it's own Embedded Structure 
    if(tweet['tweet_type'] === "only_link" || tweet['tweet_type'] === "text_link"){
        formatted_blocks.push({ color: 44269, url: tweet['linked_content'] })
        request(tweet['linked_content'], function(err, body){
            if (err){ console.log("Could not resolve URL"); return null; }
            let $ = cheerio.load(body)
            formatted_blocks[formatted_blocks.length-1]['title'] = ":link: " + $('head title').text()
            callback(formatted_tweet, formatted_blocks, video_link)
        });
    } else callback(formatted_tweet, formatted_blocks, video_link)
}


// 3.) ---- HELPER FUNCTIONS ------------------------------------------------------------------------ //


// Extracts and returns the first twitter handle present in a specified string.
//
// @param STRING The string to evaluate.
// @return A string containing the twitter handle.
//
function parse_twitter_handle(string){
    handle = string.match(/@(\w)+/);
    return handle && handle[0]
}


// Evalutates a Tweet Object and returns the tweet type.
//
// @param TWEET A JSON object containing the Tweet's data.
// @return A string specifying the tweet's type.
//
// Note: Polls are not currently supported.
//
function get_tweet_type(tweet){
    if(tweet['linked_content'] == null) return "only_text"
    else if(tweet['tweet_content'] === ''){
        if(tweet['has_video']) return "only_video"
        else if(tweet['has_external_link']) return "only_link"
        else if(tweet['images'].length > 0) return "only_images"
    } else {
        if(tweet['has_video']) return "text_video"
        else if(tweet['has_quote']) return "text_quote"
        else if(tweet['has_external_link']) return "text_link"
        else if(tweet['images'].length > 0) return "text_images"
    }
    return "unknown_type"
}


// Processes image related HTML elements included in a tweet and then compiles 
// each image's url into a single array.
//
// @param HTML_ELEMENTS The elements to parse.
// @return An array of strings containing the image's urls.
//
function parse_images(html_elements){
    var images = [], index = 0;
    for (var element in html_elements)
        if(element == index){
            images.push(html_elements[element].attribs.src)
            index++
        }
    return images;
}


// Parses and prints an Error Object generated by BOT.sendMessage().
//
// @param ERROR The error object.
//
function parse_transmit_error(error){
    if(error != null) 
        console.log("::ERROR [" + error['statusCode'] + "]: " + error['statusMessage'] + " (" + error['response']['message'] + ")")
}


// 4.) ---- PRIVATE FUNCTIONS ----------------------------------------------------------------------- //


// Logs Output to the NODEJS Console.
//
// @param STRING The string to log.
// @param NEWLINE If TRUE a newline will be appended to the end of
//                the string.
// @param INCLUDE_LOG_STRING If TRUE the LOGGING_STRING will be included.
//
function log_event(string, newline = true, include_log_string = true){
    logging_string = ''
    if(include_log_string) logging_string = LOGGING_STRING
    if(newline) process.stdout.write(logging_string + string + "\n")
    else process.stdout.write(logging_string + string)
}